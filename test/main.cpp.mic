/** @file paex_record.c
	@ingroup examples_src
	@brief Record input into an array; Save array to a file; Playback recorded data.
	@author Phil Burk  http://www.softsynth.com
*/
/*
 * $Id$
 *
 * This program uses the PortAudio Portable Audio Library.
 * For more information see: http://www.portaudio.com
 * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*
 * The text above constitutes the entire PortAudio license; however, 
 * the PortAudio community also makes the following non-binding requests:
 *
 * Any person wishing to distribute modifications to the Software is
 * requested to send the modifications to the original developer so that
 * they can be incorporated into the canonical version. It is also 
 * requested that these non-binding requests be included along with the 
 * license above.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "portaudio.h"
#include "time.h"
#include "pthread.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>
#include <string.h>
#include <dirent.h>
#include "stdlib.h"
#include <ctime>
#include "stdint.h"
#include "asr.h"


/* #define SAMPLE_RATE  (17932) // Test failure to open with this value. */
#define SAMPLE_RATE  (16000)
#define FRAMES_PER_BUFFER (160*10)
#define PROCESS_BLOCK (16*1000*1)
#define NUM_CHANNELS    (1)
/* #define DITHER_FLAG     (paDitherOff) */
#define DITHER_FLAG     (0) /**/
/** Set to 1 if you want to capture the recording to a file. */
#define WRITE_TO_FILE   (0)

/* Select sample format. */
#define PA_SAMPLE_TYPE  paInt16
typedef short SAMPLE;
#define SAMPLE_SILENCE  (0)
#define PRINTF_S_FORMAT "%d"

//#define WRITE_LOG 1

/* This routine will be called by the PortAudio engine when audio is needed.
** It may be called at interrupt level on some machines so don't do anything
** that could mess up the system like calling malloc() or free().
*/

#define BUF_LEN (1024*1024*10)
//#define BLOCK_SIZE (16000*2/10)
//#define BLOCK_SIZE (16000*2/5)

#define BLOCK_SIZE (1024*2)

extern float model[];
int16_t gAudioBuf[BUF_LEN] = {0};
void * asrData = NULL;
int dataBegin = 0;
int dataEnd = 0;

pthread_mutex_t mutex ;

int16_t threadLocalBuf[1024*1024*2] = {0};
void *AsrThreadFun(void *arg)
{
    while(1)
    {
        bool needRunAsr = false;
        int dataLen = 0;
        pthread_mutex_lock(&mutex);

        if((dataEnd - dataBegin)>= PROCESS_BLOCK)
        {
            memcpy(threadLocalBuf,(void *)(gAudioBuf+dataBegin),(dataEnd-dataBegin)*sizeof(int16_t));
            //printf("copy %d samples in asr thread\n",(dataEnd-dataBegin));
            dataLen = dataEnd-dataBegin;
            dataBegin = 0;
            dataEnd = 0;
            needRunAsr = true;
        }

        pthread_mutex_unlock(&mutex);

        if(needRunAsr == true)
        {
            //printf("to call asrrun\n");
            asrRun(asrData,threadLocalBuf ,dataLen);
        }
    }
    return NULL;
}


static int recordCallback( const void *inputBuffer, void *outputBuffer,
                           unsigned long framesPerBuffer,
                           const PaStreamCallbackTimeInfo* timeInfo,
                           PaStreamCallbackFlags statusFlags,
                           void *userData )
{
    const SAMPLE *rptr = (const SAMPLE*)inputBuffer;
    long framesToCalc;
    long i;
    int finished;

    (void) outputBuffer; /* Prevent unused variable warnings. */
    (void) timeInfo;
    (void) statusFlags;
    (void) userData;

    framesToCalc = framesPerBuffer;
    finished = paContinue;

    pthread_mutex_lock(&mutex);
    
    memcpy(gAudioBuf+dataEnd,inputBuffer,framesPerBuffer*sizeof(int16_t));

    //printf("copy %d samples\n",framesPerBuffer);
    dataEnd = dataEnd + framesPerBuffer;

    pthread_mutex_unlock(&mutex);

    return finished;
}

/*******************************************************************/
int main(int argc, char * argv[])
{
    PaStreamParameters  inputParameters,
                        outputParameters;
    PaStream*           stream;
    PaError             err = paNoError;
    int                 i;
    int                 totalFrames;
    int                 numSamples;
    int                 numBytes;
    SAMPLE              max, val;
    double              average;


    asrData = asrInit(model, false);
    
    pthread_mutex_init(&mutex,NULL);
    pthread_t myThread1;
    pthread_create(&myThread1, NULL, AsrThreadFun, NULL);

    err = Pa_Initialize();
    if( err != paNoError )
    {
        Pa_Terminate();
        return 0;
    }

    inputParameters.device = Pa_GetDefaultInputDevice(); /* default input device */
    if (inputParameters.device == paNoDevice) {
        fprintf(stderr,"Error: No default input device.\n");
        Pa_Terminate();
        return 0;
    }
    inputParameters.channelCount = 1;                    /* stereo input */
    inputParameters.sampleFormat = PA_SAMPLE_TYPE;
    inputParameters.suggestedLatency = Pa_GetDeviceInfo( inputParameters.device )->defaultLowInputLatency;
    inputParameters.hostApiSpecificStreamInfo = NULL;

    /* Record some audio. -------------------------------------------- */
    err = Pa_OpenStream(
              &stream,
              &inputParameters,
              NULL,                  /* &outputParameters, */
              SAMPLE_RATE,
              FRAMES_PER_BUFFER,
              paClipOff,      /* we won't output out of range samples so don't bother clipping them */
              recordCallback,
              NULL );
    if( err != paNoError )
    {
        Pa_Terminate();
        return 0;
    }

    err = Pa_StartStream( stream );
    if( err != paNoError )
    {
        Pa_Terminate();
        return 0;
    }
    printf("\n=== Now recording!! Please speak into the microphone. ===\n"); fflush(stdout);

    while( ( err = Pa_IsStreamActive( stream ) ) == 1 )
    {
        Pa_Sleep(1);
    }

    if( err < 0 )
    {
        Pa_Terminate();
        return 0;
    }

    err = Pa_CloseStream( stream );
    if( err != paNoError )
    {
        Pa_Terminate();
        return 0;
    }

    Pa_Terminate();
    if( err != paNoError )
    {
        fprintf( stderr, "An error occured while using the portaudio stream\n" );
        fprintf( stderr, "Error number: %d\n", err );
        fprintf( stderr, "Error message: %s\n", Pa_GetErrorText( err ) );
        err = 1;          /* Always return 0 or 1, but no other return codes. */
    }
    return err;
}

